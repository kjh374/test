완벽메ㅗㅁ.

반복문의 3요소: begin, end, step; 하나라도 누락되면 반복문 이상작동;
반복문의 범위, 시작과 끝을 잘 지정.

for문은 비긴 엔드 스텝이 한 줄에 ㄷ 들어감.
while문보다 반복문의 범위를 한눈에 보기 편함. 작성하기도 편함.

시작과 끝 범위가 확실한 반복 == for

반복문 중첩

반복문 안에 다른 반복문이 또 들어간 구조

반복문 자체를 반복해야 하는 경우에 사용한다.

ex) 단 출력 반복문을 단을 바꿔가며 반복할 때 사용한다.

탈출문
	반복문이나 switch문을 빠져 나올 때 사용한다.
	해당 키워드가 들어있는 반복문 블록을 빠져나온다.
	switch문에서 break문을 사용하면 해당 switch문을 빠져나온다.
	주로 if와 쓰인다.
	원한다면 반복문에 label을 선언해주면 break label을 통해 바로 빠져나올 수있다.

무한 루프는 반복횟수를 정하지 않가 무한하게 반복문을 실행하는 구조이다.
주로 사용자 입력을 받는 프로그램에서 사용되낟.

논리상수 true를 조건식 자리에 박아 넣으면 영원히 반복한다.
for(;;)도 사용가능하지만 while(true)를 더 많이 사용한다.

break는 반복문을 중간에 개부수고 탈출한다.
continue는 지정된 반복횟수를 모두 돌고 종료되낟

foransdptj 채ㅜ샤ㅜㅕㄷfmf tkdydgkaus wmdrkatlrdl tlfgodehlsek.
while문에서는 조건식으로 흐름이 이동한다. (증감식이 실행되지 않는다.)

배열
	배열은 같은 타입의 데이터를 하나의변수에 저장하는 자료구조이다.
	변수는 하나 당 하나의 값만 받을 수 있다.
	배열을 사용하면 여러개의 값을 하나의 배열 변수에 받을 수 있다.
	구체적으로는 배열에 값을 받는 것이 아니라 주소값이 저장되는 것이다.
	그 주소가 Heap공간의 주소를 보고 찾아갈 수 있게 도와주는 것이다.
	정확히는 객체에 저장되는 것.?
	
	배열은 고정된 크기로 선언된다. 크기변경 불가하다.
	배열은 동종모음이다. 
	
	배열 선언은 타입[] 변수이름이다.
	
	자바는 배열 자체를 데이터 타입으로 취급하므로 위의 방식을 더 선호한다.
	타입 변수이름[] 보다

	생성할 때 배열의 크기를 정해 준다.new type[n]
	타입의 기본값으로 채워져있다. 비워져 있는 것이 아니다. 스트링 타입은 null로 채워진다. double은 0.0, bulean은 false로 .

	인덱스는 배열 내부의 위치를 지정할 수 있는 값이다.
	인덱스는 0번부터 시작하고 1씩 순차적으로 증가한다.
	대괄호 안에 인덱스를 지정하여 요소에 접근할수 있다.
	배열 변수에 바로 때려 넣으면 안된다.
	인덱스는 0부터 시작하기 때문에 마지막 인덱스는 항상 배열의 길이보다 하나 작다.
	마지막 인덱스가 그를 초과하면 문법 에러는없지만 런타임 에러가 생긴다.
	배열 생성할 때, 처음이라면 new type[n]생략 가능하다.
	인덱스로 꺼낼 수 있다..
	배열의 요소를 반복적으로 처리해야 할 때 for문을 사용할 수 이싿.
	인덱스를제어변수로 사용한다.
	인덱스를 사용하지 않고 배열 자체 내부의 모습을 들여다볼 수 없다.
	배열은 객체 타입이기 때문이다.
	변수는 배열을 품기에는 작은 영역이다.
	Heap 영역의 주소값이 저장되고, 배열에 접근할 수 있도록 구성된다. ㅈ
	주소는 자동 지정된다.
	arrays 클래스가 제공하는 toString()을 사용하면 된다.

	for-each문(향상된 for문)
	자바 5부터 추가된 기능이다.
	배열과 컬렉션에서 사용할 수 있다.
	제어변수(인덱스)없이 배열 내부 요소를 전체 참조할 수 있게 도와준다.
	for(배열 요소를 받을 수 있는 변수 : 배열 또는 컬렉션 이름){}
	
	장점:
	반복문의 제어변수나 인덱스 변수선언없이 코드가 간결해진다.
	구조적 변화 없으면 for문보다 바르다.
	for-each문의 단점:
	인덱스정보를 알 수 없다. 
	범위를 세밀하게 지정할 수 없다.
	요소를 삭제할 수 없다.

	javascript에서는 for(let day of week){} 를 사용한다.
	for(let idx of week){} idx에 인덱스가 하나씩 들어온다. 객체도 들어올 수 있다.
	const obj = {
		name : "hong"
		age : 30	
	}
	
	
	입력을 받으려면 Scanner sc = new Scanner(System.in);

	System.in은 표준 입력 형식이다.
		type name = sc.nexttype();

자바
	자바란 1995년에 발표되었다.
	자바는 객체지향 프로그래밍 언어이다.
	수많은 프로그램들이 자바를 통해서 만들어진다.
	자바는 간단하다.
	자바는 C++에 가깝지만 훨씬 더 개발자 친화적이다.
	메모리 자원 관리 등 초보자가 부담을 느끼는 부분을 스스로 처리한다.(문법 제공자체를 안한다.)
	기본 타입을 제외한 거의 모든 것이 객체로 이루어져 이싿.
	객체는 여러가지 정보들을 담는 큰 데이터 덩어리라고 생각하면 된다.
	



	
	if(num % 7 ==0){
	}else if(num ==0){
	} 
	을 살리려면 어떻게 해야될까? num==0 위치를 위로 빼내거나 if 안을 false로 만들어줘도 된다.

	선언만 할 때에는 값을 지정하지 않아도 된다. ==초기화할 필요가 없다.
	어차피 다른 값으로 대체될 것이라면 아무값으로 초기화해도 된다. 

	may not have been initialized : 값이 안들어간 경우가 있다. 모든 경우의 수를 따지지 않았다. 무언가를 놓치고 있다.
	초기화를 미리 해두면 에러를 잡아내기 수월하다.

	출력문이 모든 경우에 다 있는 것이 보기 싫다면 맨 아래에 한번에 쓰면 됨. 미리 변수를 따로 만들어서 

	판단할 때 주로 변수이름으로  flag를 사용한다. 
	조건식이 false 값을 가지면 내부에 있는 실행문이 실행되지 않는다. 

 	while문 내부 조건식을 if문이라고 생각하면 된다.
	값을 보존하고 싶으면 새로운 변수에 전달하면 된다.

	배열
		값이 명확하지 않으면 초기화 안하고 생성만 해두면 됨.
	
문자열 동등 비교	
	자바에서는 문자열 동등 비교 시 '==' 연산자를 사용하면 제대로 비교가 되지 않는다.
	문자열 String 타입이 기본 데이터 타입이 아닌 객체 참조 타입이기 때문이다.
	객체 참조 타입은 해당 값을 직접 들고 있는 게 아니라 객체의 주소값을 들고 있기 때문에, 문자열이 아무리 같더라도 주소가 다르면 false를 도출한다.
	그러므로 문자열 동등 비교를 진행할 때는 비교문자열1.equals(비교문자열2) 을 사용하여 진행해야 된다.
	기본 데이터 타입은 변수와 값이 같이 매핑되어 저장된다.
	문자열은 내부에는 값 뿐만 아니라 함수 등도 있기 때문에 객체이다.
	null을 보고 싶지 않다면? 원하는 이름까지 요소를 출력하고 싶다면? 자바에서 제공하는 함수를 수정할 수 없다. 그러므로 배열요소를 받아주는 변수를 따로 선언해서 반복문으로 하나씩 받아서 하나씩 출력하고 null이 오는 순간 출력을 멈추면 된다. 출력은 배열형태로 나타나는 것이 아니고 일반 출력이다.
	
for-each문
	for each문은 좌항에 배열 타입과 같은 데이터 타입의 변수를 새로 선언하는 것이다.
	null이라는 키워드는 문자가 아니므로 ==으로 비교해도 무방하다. 문자끼리 비교할 때에만 equals()를 쓴다.
	배열도 수정할 수 있고, 배열의 값도 수정할 수 있다.
배열
	변경하고자 하는 값이 배열내에서 몇번째인지 탐색할 수 있어야 된다.
	변경하고자 하는 값을 입력하세요. 그 입력값이 해당 배열에서 몇번째인지 탐색하는 방법은?
	입력값과 요소값을 반복해서 하나씩 비교하면 된다.


	for문도 반복문 전에 제어변수를 선언할 수 있다.
	flag?????? true인데 왜 false
	
	배열의 삭제는 없다. 배열은 고정된 크기를 가지고 있다. 단, 삭제처럼 보이는 방법은 존재한다.
	일단 삭제하고자 하는 요소의 인덱스를 파악한다.
	삭제하고자 하는 값을 기준으로 뒤에 위치하는 값들을 앞으로 원하는 만큼씩 땡겨온다. 
	맨뒤에는 값이 그대로 남는다. 이걸 해결하기 위해 크기가 하나 작은 새로운 배열을 선언한다. 
	반복문을 이용해서 새로운 배열에 그대로 내려준다. 새로운 배열의 주소를 원본 배열에 넘겨준다. 
	그리고 새로운 배열에는 null값을 주면 gc에 의해 삭제되기 쉽다.
	           	  				

	컨티뉴 이용하면 더 편하지 않을까..?
		

	배열 안에 있는 요소가 배열인 것이 2차원 배열이다.
	그럼 요소의 배열에 주소가 저장되는 건가?


	이미 배열에 존재하는지 확인하려면??
	
for-each문은 브레이크로 못나오나? 

크기는 대괄호로 설정한다.

배불러, 그만을 마지막에 입력해야 브레이크 걸려서 출력이 안된다.

배불러를 중복확인할 필요 없으니까 그다음에 써준다.

	컨티뉴를 쓰면 for문은 인덱스가 증가해서 다음 회차로 넘어가서 그회차는 디폴트값이 들어간다. 
	그러므로 continue 이전에 i--; 를 추가하거나 와일문을 써야된다.

 두번째 for문 첫번째 포문 변수 받아서 안되나??

왜 nextline은 되지? 입력받은 값이없을때, 화이트공백.

가독성이 너무 안좋다. 

언제 종료될 지 알 수 없으니까 while(true)

괄호에 마우스 대면 어디 괄호인지 나온다.

	3: 인덱스탐색

		
불린형 변수는 기본값이 false이며, 이와 무관하게 조건식 안에서 무조건 true, !(반전 연산자)가 붙으면 false다.
